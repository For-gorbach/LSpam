from pyrogram import *  # импорт всего из библиотеки для работы с юзерботом
from settings import *  # импортируем данные из файла settings
import datetime as dt  # импортируем библиотеку для получения данных о времени на устройствеы
import pickledb as DB  # импортируем библиотеку для создания примитивной базы данных
from random import randint  # импорт функции выдачи рандомных (по заданному ограничению) чисел (для рандомной доп-задержки)
from time import sleep  # импорт функции засыпания программы

app = Client("my_account", api_id=int(api_id), api_hash=api_hash)  # создаем профиль для юзербота


def main():  # основная функция
    names = []  # список в котором будут храниться имена

    def join_in_chat(id):  # функция для входа в чат
        try:  # проверка на наличие ошибок
            app.join_chat(app.get_chat(id)["invite_link"])  # входим в чат по ссылке полученной с помощью id
            print(f"Вы вошли в чат с id {id} ({app.get_chat(id)['title']})")  # пишет в какой чат мы зашли
        except errors.exceptions.flood_420.FloodWait:  # если произошла ошибка от того что вы есть в чате то
            pass  # null функция, что бы ничего не происходило

    def getnames():  # функция для получения имени (ссылки) всех пользователей в чате
        with app:  # начинаем работу с юзерботом
            for chat in chats:  # проходим по списку id чатов
                join_in_chat(int(chat))  # запуск функции для входа в чат
                for user in app.get_chat_members(int(chat)):  # берем профили пользователей из группы
                    names.append(user.user.username)  # берем имя пользователя и добавляем его в список
        return names  # возвращаем список имен

    names = set(getnames())  # вписываем в переменную names ( уникальный с помощью set() ) список имен который вернула функция getnames

    print(f"Сообщение должно будет быть отправлено следующим пользователям: @{' @'.join(names)}!")  # пишем кому будут отправлены сообщения

    def sender():  # функция отправки сообщений
        try:  # проверка на наличие ошибок
            hour = int(dt.datetime.now().hour)  # переменная для того что бы знать сколько сейчас часов
            day = int(dt.datetime.now().day)  # переменная для того что бы знать какой сейчас день

            with app:  # начинаем работу с юзерботом
                for name in names:  # перебор имен из соответствующего списка
                    db = DB.load(f"../users/{name}.txt", True)  # загружаем файл (бд) с названием соответствующим имени пользователя (для удобства) и записываем в переменную
                    if str(db.getall()) == "dict_keys([])":  # если бд пустая (или отсутствует) то
                        db.set("hour", hour - 8)  # создаем бд и вписываем время (часы) (на 8 часов меньше чем текущие что бы сработал "первый запуск")
                        db.set("day", day)  # создаем бд и вписываем день

                    if hour - 8 >= db.get("hour"):  # если текущий час на 8 часов больше тому что записан в бд то
                        app.send_message(f"@{name}", message)  # отправка сообщения
                        db.set("hour", hour)  # обновляем данные часа в бд на текущие
                        db.set("day", day)  # обновляем данные про день в бд на текущие
                        print(f"Сообщение отправлено пользователю @{name}!")  # пишем кому отправлено сообщение

                    elif db.get("day") != day:  # если текущий час на 8 часов больше тому что записан в бд или наступил след. день (или и то и то) то
                        app.send_message(f"@{name}", message)  # отправка сообщения
                        db.set("hour", hour)  # обновляем данные часа в бд на текущие
                        db.set("day", day)  # обновляем данные про день в бд на текущие
                        print(f"Сообщение отправлено пользователю @{name}!")  # пишем кому отправлено сообщение

        except Exception as ex:  # обработка ошибки
            print(f'Ошибка: "{ex}"')  # пишем ошибку


    while True:  # вечный цикл
        sender()  # запуск функции отправки сообщений
        sleep( randint(0, 10) )  # засыпание программы на рандомное (от 0 до 10) секунд


main()  # запуск основной функции
